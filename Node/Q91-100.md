# 91. How Do You Design a Scalable API in Node.js?

### Explanation

**A scalable API must handle:**

- High traffic

- Failures

- Growth

**Key Principles**

- Stateless services

- Horizontal scaling

- Caching

- Rate limiting

- Async processing

### Example Architecture

```
Client → API Gateway → Node Cluster → Redis → DB
```

### Interview Tip

Stateless APIs scale best.

# 92. What Is a Message Queue?

### Explanation

A message queue enables asynchronous communication between services.

**Used when:**

- Tasks are slow

- Reliability is needed

- Decoupling services

### Example

```
API → Queue → Worker → DB
```

# 93. Use Cases of Kafka / RabbitMQ With Node.js

### Kafka

- Event streaming

- Real-time analytics

- Log aggregation

### RabbitMQ

- Task queues

- Background jobs

- Email processing

### Interview Tip

Kafka = high throughput
RabbitMQ = task reliability

# 94. What Is Eventual Consistency?

### Explanation

Data becomes consistent over time, not immediately.

### Example

```
Order created → Payment pending → Inventory update → Confirmation
```

### Interview Tip

Common in microservices.

# 95. What Is Distributed Locking?

### Explanation

Prevents multiple services from modifying the same resource concurrently.

### Tools

- Redis (Redlock)

- Zookeeper

### Example

```
await redis.lock("order:123");
```

# 96. How Does Node.js Handle CPU-Intensive Tasks?

### Explanation

Node.js offloads CPU-heavy work to:

- Worker threads

- Child processes

- Separate microservices

### Interview Tip

Never block the event loop.

# 97. What Are Microservices?

### Explanation

Microservices are small, independently deployable services.

### Benefits

- Independent scaling

- Fault isolation

- Faster deployments

### Tradeoff

- Operational complexity

# 98. Node.js Monolith vs Microservices

| Monolith        | Microservices     |
| --------------- | ----------------- |
| Simple          | Scalable          |
| Single codebase | Multiple services |
| Easy to deploy  | Complex infra     |

Start monolith → evolve.

# 99. How Do You Secure APIs at Scale?

### Techniques

- API gateway

- OAuth/JWT

- Rate limiting

- TLS

- Monitoring

### Interview Tip

Security must be automated.

# 100. How Would You Design a Production-Ready Node.js Backend?

### Must-Have Checklist

- Clean architecture

- Input validation

- Auth & authorization

- Centralized logging

- Monitoring & alerts

- CI/CD pipeline

- Auto-scaling

### Final Architecture

```
Client → CDN → API Gateway → Node Cluster → Cache → DB
→ Queue → Workers
```
