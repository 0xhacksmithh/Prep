# 31. Explain Node.js Architecture

### Explanation

Node.js architecture is built to handle high concurrency with low resource usage.

### Core Components

- V8 Engine – Executes JavaScript

- Event Loop – Handles async callbacks

- libuv – Manages async I/O

- Thread Pool – Executes blocking tasks

- Callback Queue

### Flow

```
Request → Event Loop → Async Task → Thread Pool → Callback → Event Loop → Response
```

### Interview Tip

Node does NOT create a new thread per request.

# 32. What are Streams in Node.js?

### Explanation

Streams allow you to process data in chunks instead of loading everything into memory.

Used for:

- File handling

- Network sockets

- Video streaming

### Example

```
const fs = require("fs");

const readStream = fs.createReadStream("bigfile.txt");
readStream.on("data", chunk => {
  console.log(chunk.toString());
});
```

### Interview Tip

Streams are memory-efficient.

# 33. Types of Streams

### Explanation

There are **4 types of streams**:

- **Readable** – Read data

- **Writable** – Write data

- **Duplex** – Read & Write

- **Transform** – Modify data

### Example (Transform)

```
const { Transform } = require("stream");

const upperCase = new Transform({
  transform(chunk, enc, cb) {
    cb(null, chunk.toString().toUpperCase());
  }
});
```

# 34. Streams vs Buffers

### Explanation

| Streams              | Buffers             |
| -------------------- | ------------------- |
| Chunk-based          | Full data in memory |
| Memory-efficient     | Memory heavy        |
| Best for large files | Best for small data |

### Example

```
// Buffer
fs.readFile("bigfile.txt", cb);

// Stream
fs.createReadStream("bigfile.txt");
```

# 35. What is a Buffer?

### Explanation

A Buffer stores raw binary data temporarily in memory.

Node uses Buffers because JavaScript cannot handle binary data natively.

### Example

```
const buffer = Buffer.from("Hello");
console.log(buffer); // <Buffer 48 65 6c 6c 6f>
```

# 36. What is Piping in Node.js?

### Explanation

Piping connects output of one stream to input of another.

### Example

```
fs.createReadStream("input.txt")
  .pipe(fs.createWriteStream("output.txt"));
```

### Interview Tip

Pipes automatically manage backpressure.

# 37. What is the cluster module?

### Explanation

The cluster module allows you to use all CPU cores by spawning multiple Node processes.

### Example

```
const cluster = require("cluster");
const os = require("os");

if (cluster.isPrimary) {
  for (let i = 0; i < os.cpus().length; i++) {
    cluster.fork();
  }
} else {
  require("./server");
}
```

### Interview Tip

Each worker has its own event loop.

# 38. What is a Child Process?

### Explanation

Child processes allow Node.js to run external system commands.

Used for:

- CPU-heavy tasks

- OS-level operations

### Example

```
const { exec } = require("child_process");

exec("node -v", (err, stdout) => {
  console.log(stdout);
});
```

# 39. Difference between `spawn`, `fork`, and `exec`

| Method  | Use Case             |
| ------- | -------------------- |
| `spawn` | Large data streams   |
| `fork`  | Node.js processes    |
| `exec`  | Small command output |

### Example

```
spawn("ls");
fork("worker.js");
exec("node -v");
```

# 40. Blocking vs Non-Blocking Code

### Explanation

Blocking code stops the event loop, preventing other requests.

### Example

```
// Blocking
fs.readFileSync("file.txt");

// Non-blocking
fs.readFile("file.txt", cb);
```

### Interview Tip

Blocking operations kill scalability.
