# 41. What is Pessimistic Locking?

Pessimistic locking assumes concurrent conflicts are likely, so it locks data when reading or writing.

### How it works

- Lock row/table before update

- Prevents other transactions from changing the data until transaction completes

### Example

```
SELECT * FROM accounts
WHERE id = 1
FOR UPDATE;
```

- Transaction 1 locks account 1

- Transaction 2 waits until Transaction 1 commits or rolls back

### Use Case

- Banking systems

- Critical inventory updates

**Pros:** Safe
**Cons:** Can cause deadlocks, slower performance

# 42. What is MVCC (Multi-Version Concurrency Control)?

**MVCC** allows non-blocking reads by maintaining multiple versions of data.

### How it works

- Each transaction sees a snapshot

- Writers don’t block readers

- Readers don’t block writers

### Example

- Transaction T1 reads old version

- Transaction T2 updates row → creates new version

- T1 still sees old data until committed

### Benefit

- High concurrency

- Prevents read locks

**Used in:** PostgreSQL, MySQL InnoDB, Oracle

# 43. What is Query Optimization?

**Query optimization** is improving performance of SQL queries.

### Techniques

- `Indexing`: Use indexes on frequently queried columns

- `**Avoid SELECT *`: Fetch only needed columns

- `Joins`: Optimize join order

- `Execution Plan`: Analyze using EXPLAIN

- `Caching`: Store frequent results

### Example

```
-- Poor
SELECT * FROM orders WHERE customer_id = 1;

-- Optimized with index
CREATE INDEX idx_customer ON orders(customer_id);
```

# 44. What is a Covering Index?

A covering index contains all columns needed for a query, avoiding a table lookup.

### Example

```
CREATE INDEX idx_orders_covering ON orders(customer_id, order_date);
SELECT customer_id, order_date FROM orders WHERE customer_id = 1;
```

- Query can be served entirely from the index

**Benefit:** Faster query performance, less disk access

# 45. What is Database Partitioning?

Partitioning splits large tables into smaller, manageable pieces.

### Types

**1.Horizontal partitioning:** Split rows

```
Orders_2025, Orders_2026
```

**2.Vertical partitioning:** Split columns

```
Orders_basic (id, date), Orders_details (id, items)
```

**3.Hash partitioning:** Distribute rows via hash function

**4.Range partitioning:** Based on ranges (e.g., date)

**Benefits:**

- Faster queries

- Manageable backups

- Easier scalability

# 46. What is a Materialized View?

A materialized view stores query results physically instead of being computed on the fly.

### Example

```
CREATE MATERIALIZED VIEW monthly_sales AS
SELECT SUM(amount) AS total, MONTH(order_date) AS month
FROM orders
GROUP BY MONTH(order_date);
```

- Querying `monthly_sales` → much faster than recomputing

**Use case:** Analytics dashboards, reporting

# 47. What is Write-Ahead Logging (WAL)?

**WAL** ensures durability in databases.

### How it works

- Changes are written to log first

- Changes applied to actual table later

- On crash → replay log to restore

### Example

- PostgreSQL uses WAL

```
Transaction: UPDATE accounts SET balance=1000 WHERE id=1
→ Log written
→ Update applied
```

**Benefit:** Guarantees ACID durability

# 48. What is the N+1 Query Problem?

Occurs when code issues one query to get items, then N queries for related data.

### Example

```
-- Fetch users
SELECT * FROM users;

-- Then for each user, fetch orders
SELECT * FROM orders WHERE user_id = ?;
```

- 1 query + N queries → inefficient

- Fix: Use JOIN or IN query

```
SELECT u.id, o.id
FROM users u
LEFT JOIN orders o ON u.id = o.user_id;
```

# 49. What is SQL Injection?

SQL Injection is a security vulnerability where malicious SQL is executed.

### Example

```
-- Unsafe
SELECT * FROM users WHERE username = ' " + userInput + " ';

-- If userInput = ' OR '1'='1
-- Query becomes always true → data leak
```

### Prevention

- Use prepared statements / parameterized queries

- Validate input

- Limit privileges

```
// Node.js example
db.query("SELECT * FROM users WHERE username = ?", [userInput]);
```

# 50. How to Optimize Slow Queries?

### Techniques

- `Indexes` → Use indexes on WHERE, JOIN, ORDER BY columns

- `Avoid SELECT` → Fetch only required columns

- `EXPLAIN` → Analyze query plan

- `Denormalization` → For high-read workloads

- `Caching` → Redis, Memcached

- `Partitioning` → Split large tables

- `Batch operations` → Instead of many small queries

### Example

```
-- Slow query
SELECT * FROM orders WHERE customer_id = 123 AND status='pending';

-- Optimized
CREATE INDEX idx_customer_status ON orders(customer_id, status);
```

**Interview Tip**: Always explain why and how performance improves.
